# graph

TODO: tranlate to English

Существует мнение, что поскольку уже множество раз предпринимались неудачные попытки реализовать визуальное программирование и всякие автоматические генерации кода из uml и других диаграм, то это в общем провальная затея. Но растущая попудярность лоу/ноу-код решений заставляет в этом засомневаться.
И я решил попробовать.

Код программы можно представить в виде графа. Все же знают про AST. Направленное дерево, ноды - функции, их потомки - это их аргументы, которые так же могут быть функциями (иметь потомков). Если потомков нет - то это агрумент с фиксированным значением. Граф вычисляется снизу вверх, то есть сначала идут функции, конкретные значения аргументов которых исзвестны, чтобы дать возможность вычислиться родительским нодам-функциям, передав им так же конкретные значения в виде аргументов. Последним вычисляется вершина дерева, которая явлется главной функцией, которая и вернёт итоговый результат.

Лисп (и, в частности, clojure), представляющий собой вложенные списки как раз является текстовым представлением такого дерева (а на самом деле такое дерево можно посмотроить для лубого ЯП и оно и спроится для выполнения кода). И проблема именно в его "текстовости". Текст не удобно читать, в нём не удобно разбираться. Чтобы разобратсья в коде всё равно приходится рисовать схемы.

TODO
Дополнительные цели, которые считаю "правильными" и которые хотелось бы достичь, помимо возможности визуального манипулирования кодом:
Одна из "фишек" функционального программирования это то, что всё является функциями. Нет всяких паттернов и кучи вспомогательных языковых конструкций. Пользовательский интерфейс, по-меому, тоже должен состоять из функций, еоторые пользвоатель может запустить 

Визуальное представление кода не является задачей этой библиотеки. Она отвечает за представление графа в виде структуры данных, его безопасное редактирование и исполнение.

Работать непосредственно с чистым AST не получится. Всё-таки AST строится именно для исполнения, а наща цель - упростить понимание в процессе написания, редактирования и чтения.

Осбенности графового представления, используемого в этой библиотеке:
Все функции хранятся в едином хранилище (в виде структур данных) и могут быть получены по имени (идентификатору). Существует два типа функций.
Первый - базовые/низкоуровневые функции. Во время выполнения просто вызываются встроенные функции языка. В классическом AST это был бы единственный вид функций/нод, принимающий аргументы.
Второй - составные/высокоуровневые функции. Представляют из себя граф в виде мапы. Ключи - локальные имена нод (могут использоваться в качестве ссылки только внутри текущего графа). По кючу :return лежит главная/корневая функция, которая в итоге вернёт результат (фиксированное имя для того, чтобы знать, с какого узла начинать вычисления).
Значения - заполненный (полностью или частично) "шаблон" функции - другая функция из хранилища, для которой частично или полностью указаны значения аргументов. В качестве значения аргументов могут быть как фиксированные "готовые" значения, так и такие же шаблоны функций, аргументы которых надо так же рекурсивно вычислить. Если значение аргумента не указано, то он становится внешним аргументом для текущей функции-графа - ожидается, что он будет передан при использовании данной функции (в других функциях).
Такая шаблонная система позволяет переиспользовать графы/код, а так же даёт дополнительные возможности (ограничить доступ к отдельным частям кода для групп пользователей)
Как такие шаблоны представлено в структурах данных в общем хранилище: вектор из двух элементов (TODO: переделать тоже в мапу?): первый - имя другой базовой или составной функции (для ссылки), которая будет использоваться в качестве шаблона, второй - мапа с аргументами для этой функции. В этой мапе с аргументами, ключ - имя аргумента, значение, соответственно - значение аргумента. В качестве значения может быть фиксированное значение либо локальное имя-ссылка на другую ноду графа. Если внутренней ноды с таким именем не существует - значит, это внешний аргумент текущего графа-функции (ожидается, что он будет передан при использовании функци).
Так же значением аргумента может быть вектор, элементами которого могут быть другие такие же значения аргумента. Это используется при необходимости ограничить кол-во аргументов для функций, у которых их может быть бесконечное количество. TODO: а так же, чтобы указать значения нескольких первых и/или последних аргументов отдельно

Была идея не исспользовать локальные имена, а сразу, в качестве значения аргументов использовать шаблонные функции, но тогда в сложных функциях может возникнуть очень глубокая вложенность, а такое неудобно хранить.
Была идея просто не указывать какой-то аргумент в аргументах шаблонной функции, если его следует сделать внешним, но тогда код, отвечающй за поиск нужных аргументов при исполнении функции становится сложнее, чем код, который автоматически будет генерировать внутрениие имена для нод, особенно, если значение аргумента - вектор. Но, возможно, следует попробовать реализовать такую возможность позже, чтобы избавить пользователя от необходимости именовать аргументы самостоятельно или использвоать нечитаемые, атоматически сгенерированные имена. А в качестве имен внешних аргументов использовать вектор с путём до них
Была идея, если все аргументы функции - внешние, вместо вектоора-шаблона - просто использовать имя этой функции. Была отброшена по той же причине, что и предыдущая. TODO: ключ с указанием другой ноды вместо шаблона функции может пригодиться для работы с функциями как с оббъектами первого порядка

TODO
Cases:

- first-class functions. Возможнойть передавайть функции как аргументы. То есть нужна возмоэность при выполнении функции проверить, если аргумент - граф, то сначала "решить его", а потом
